"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaGrid = exports.Color = exports.Pixel = exports.Row = exports.Grid = exports.BebopData = exports.DeltaGridOpcode = exports.PixelOpcode = exports.GridOpcode = exports.ProtocolVersion = void 0;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.4.6
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
const bebop_1 = require("bebop");
exports.ProtocolVersion = 1;
exports.GridOpcode = 1;
exports.PixelOpcode = 2;
exports.DeltaGridOpcode = 3;
exports.BebopData = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        view.writeUint32(message.protocolVersion);
        view.writeUint32(message.opcode);
        view.writeBytes(message.encodedData);
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        field0 = view.readUint32();
        let field1;
        field1 = view.readUint32();
        let field2;
        field2 = view.readBytes();
        let message = {
            protocolVersion: field0,
            opcode: field1,
            encodedData: field2,
        };
        return message;
    },
};
exports.Grid = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        {
            const length0 = message.rows.length;
            view.writeUint32(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                exports.Row.encodeInto(message.rows[i0], view);
            }
        }
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        {
            let length0 = view.readUint32();
            field0 = new Array(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                let x0;
                x0 = exports.Row.readFrom(view);
                field0[i0] = x0;
            }
        }
        let message = {
            rows: field0,
        };
        return message;
    },
};
exports.Row = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        {
            const length0 = message.pixels.length;
            view.writeUint32(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                exports.Color.encodeInto(message.pixels[i0], view);
            }
        }
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        {
            let length0 = view.readUint32();
            field0 = new Array(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                let x0;
                x0 = exports.Color.readFrom(view);
                field0[i0] = x0;
            }
        }
        let message = {
            pixels: field0,
        };
        return message;
    },
};
exports.Pixel = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        view.writeUint32(message.x);
        view.writeUint32(message.y);
        exports.Color.encodeInto(message.color, view);
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        field0 = view.readUint32();
        let field1;
        field1 = view.readUint32();
        let field2;
        field2 = exports.Color.readFrom(view);
        let message = {
            x: field0,
            y: field1,
            color: field2,
        };
        return message;
    },
};
exports.Color = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        view.writeByte(message.red);
        view.writeByte(message.green);
        view.writeByte(message.blue);
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        field0 = view.readByte();
        let field1;
        field1 = view.readByte();
        let field2;
        field2 = view.readByte();
        let message = {
            red: field0,
            green: field1,
            blue: field2,
        };
        return message;
    },
};
exports.DeltaGrid = {
    encode(message) {
        const view = bebop_1.BebopView.getInstance();
        view.startWriting();
        this.encodeInto(message, view);
        return view.toArray();
    },
    encodeInto(message, view) {
        const before = view.length;
        {
            const length0 = message.delta.length;
            view.writeUint32(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                exports.Pixel.encodeInto(message.delta[i0], view);
            }
        }
        const after = view.length;
        return after - before;
    },
    decode(buffer) {
        const view = bebop_1.BebopView.getInstance();
        view.startReading(buffer);
        return this.readFrom(view);
    },
    readFrom(view) {
        let field0;
        {
            let length0 = view.readUint32();
            field0 = new Array(length0);
            for (let i0 = 0; i0 < length0; i0++) {
                let x0;
                x0 = exports.Pixel.readFrom(view);
                field0[i0] = x0;
            }
        }
        let message = {
            delta: field0,
        };
        return message;
    },
};
